diff --git a/garaged/setup.py b/garaged/setup.py
index 512879b..7a1bdba 100644
--- a/garaged/setup.py
+++ b/garaged/setup.py
@@ -12,15 +12,19 @@ REQUIRED = [
     # Please keep alphabetized
     'akro',
     'click>=2.0',
-    'cloudpickle==1.3',
+    # 'cloudpickle==1.3',
+    'cloudpickle',
     'cma==2.7.0',
     #'dowel==0.0.3',
-    'gym[atari,box2d,classic_control]' + GYM_VERSION,
-    'joblib<0.13,>=0.12',
+    #'gym[atari,box2d,classic_control]' + GYM_VERSION,
+    'gym[box2d,classic_control]' + GYM_VERSION, # MOVED TO ALE-PY
+    #'joblib<0.13,>=0.12',
+    'joblib',
     'numpy>=1.14.5',
     'psutil',
     'python-dateutil',
-    'ray<=0.8.6',
+    #'ray<=0.8.6',
+    'ray',
     'scikit-image',
     'scipy',
     'setproctitle>=1.0',
diff --git a/iod/dads.py b/iod/dads.py
index e7fd43c..e7f04d5 100644
--- a/iod/dads.py
+++ b/iod/dads.py
@@ -1,10 +1,10 @@
 import numpy as np
 import torch
 
-from iod.metra import METRA_bl
+from iod.metra import METRA
 
 
-class DADS(METRA_bl):
+class DADS(METRA):
     def __init__(
             self,
             **kwargs,
diff --git a/iod/iod.py b/iod/iod.py
index d0c5774..530c282 100644
--- a/iod/iod.py
+++ b/iod/iod.py
@@ -20,7 +20,7 @@ import random
 from envs.AntMazeEnv import MazeWrapper, GoalReachingMaze, plot_trajectories, plot_value
 import matplotlib.pyplot as plt
 import os
-from iod.ant_eval import *
+# from iod.ant_eval import *
 from iod.agent import *
 from iod.viz_utils import PlotMazeTrajDist, PlotMazeTrajWindowDist, viz_dist_circle, PlotGMM
 
@@ -257,83 +257,83 @@ class IOD(RLAlgorithm):
         '''
         plot training traj
         '''
-        with torch.no_grad():
-            # if (runner.step_itr + 2) % self.n_epochs_per_log == 0 and wandb.run is not None:
-            if wandb.run is not None and self.method['phi'] != 'baseline':
-                Pepr_viz = True
-                if 'maze' in self.env_name or 'lm' in self.env_name:
-                    fig, ax = plt.subplots(1, 2, figsize=(15, 6))
-                    fig.suptitle("Epoch:" + str(runner.step_itr))
-                    env = runner._env
-                    env.draw(ax[0])
-                    list_viz_traj = []
-                    All_Repr_obs_list = []
-                    All_Goal_obs_list = []
-                    for i in range(len(trajectories)):
-                        # plot phi
-                        if Pepr_viz:
-                            if self.method['phi'] == 'Projection':
-                                psi_s = self.Psi(self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean).cpu().numpy()
-                            else:
-                                psi_s = self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean.cpu().numpy()
-                            psi_g = trajectories[i]['agent_infos']['option']
-                            All_Repr_obs_list.append(psi_s)
-                            All_Goal_obs_list.append(psi_g)
+        # with torch.no_grad():
+        #     # if (runner.step_itr + 2) % self.n_epochs_per_log == 0 and wandb.run is not None:
+        #     if wandb.run is not None and self.method['phi'] != 'baseline':
+        #         Pepr_viz = True
+        #         if 'maze' in self.env_name or 'lm' in self.env_name:
+        #             fig, ax = plt.subplots(1, 2, figsize=(15, 6))
+        #             fig.suptitle("Epoch:" + str(runner.step_itr))
+        #             env = runner._env
+        #             env.draw(ax[0])
+        #             list_viz_traj = []
+        #             All_Repr_obs_list = []
+        #             All_Goal_obs_list = []
+        #             for i in range(len(trajectories)):
+        #                 # plot phi
+        #                 if Pepr_viz:
+        #                     if self.method['phi'] == 'Projection':
+        #                         psi_s = self.Psi(self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean).cpu().numpy()
+        #                     else:
+        #                         psi_s = self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean.cpu().numpy()
+        #                     psi_g = trajectories[i]['agent_infos']['option']
+        #                     All_Repr_obs_list.append(psi_s)
+        #                     All_Goal_obs_list.append(psi_g)
                         
-                        # plot the subgoal
-                        if 'sub_goal' in trajectories[i]['agent_infos'].keys():
-                            sub_goal = trajectories[i]['agent_infos']['sub_goal'][0]
-                            ax.scatter(sub_goal[0], sub_goal[1], s=50, marker='x', alpha=1, edgecolors='black', label='target.'+str(i))
-                        # plot the traj
-                        viz_traj = {}
-                        viz_traj['observation'] = trajectories[i]['observations']
-                        viz_traj['info'] = []
-                        for j in range(len(trajectories[i]['observations'])):
-                            viz_traj['info'].append({'x':viz_traj['observation'][j][0], 'y':viz_traj['observation'][j][1]})
-                        list_viz_traj.append(viz_traj)
-                    plot_trajectories(env, list_viz_traj, fig, ax[0])
-                    title_txt = "train_policy: " + str(self.train_policy) + "\n train_phi: " + str(self.train_phi)
-                    ax[0].set_title(title_txt)
-                    ax[0].legend(loc='lower right')
-                    path = wandb.run.dir
-                    if self.method['phi'] == 'Projection':
-                        ax[1].set_xlim(-1, 1)
-                        ax[1].set_ylim(-1, 1)
-                        # plot GMM
-                        window_dist = self.UpdateGMM(self.DistWindow, mix_dist_prob=None, device=self.device)
-                        if len(self.SfReprBuffer) > 0:
-                            psi_z = np.array(self.SfReprBuffer)
-                        else:
-                            psi_z = None
-                        PlotGMM(window_dist, psi_z=psi_z, fig=fig, ax=ax[1], device=self.device, dim=self.dim_option)
-                    # plot Traj in Z-space
-                    PCA_plot_traj(ax[1], All_Repr_obs_list, All_Goal_obs_list, path, path_len=self.max_path_length, is_goal=True)
-                    filepath = os.path.join(path, "train_Maze_traj.png")
-                    print(filepath)
-                    plt.savefig(filepath) 
-                    plt.close()
-                    if self.save_debug == True or runner.step_itr % self.n_epochs_per_eval == 0:
-                        wandb.log(({"train_Maze_traj": wandb.Image(filepath)}))
-
-                else:
-                    fig, ax = plt.subplots()
-                    env = runner._env
-                    list_viz_traj = []
-                    All_Repr_obs_list = []
-                    All_Goal_obs_list = []
-                    for i in range(len(trajectories)):
-                        # plot phi
-                        if Pepr_viz:
-                            if self.method['phi'] == 'Projection':
-                                psi_s = self.Psi(self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean).cpu().numpy()
-                            else:
-                                psi_s = self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean.cpu().numpy()
-                            psi_g = trajectories[i]['agent_infos']['option']
-                            All_Repr_obs_list.append(psi_s)
-                            All_Goal_obs_list.append(psi_g)
+        #                 # plot the subgoal
+        #                 if 'sub_goal' in trajectories[i]['agent_infos'].keys():
+        #                     sub_goal = trajectories[i]['agent_infos']['sub_goal'][0]
+        #                     ax.scatter(sub_goal[0], sub_goal[1], s=50, marker='x', alpha=1, edgecolors='black', label='target.'+str(i))
+        #                 # plot the traj
+        #                 viz_traj = {}
+        #                 viz_traj['observation'] = trajectories[i]['observations']
+        #                 viz_traj['info'] = []
+        #                 for j in range(len(trajectories[i]['observations'])):
+        #                     viz_traj['info'].append({'x':viz_traj['observation'][j][0], 'y':viz_traj['observation'][j][1]})
+        #                 list_viz_traj.append(viz_traj)
+        #             plot_trajectories(env, list_viz_traj, fig, ax[0])
+        #             title_txt = "train_policy: " + str(self.train_policy) + "\n train_phi: " + str(self.train_phi)
+        #             ax[0].set_title(title_txt)
+        #             ax[0].legend(loc='lower right')
+        #             path = wandb.run.dir
+        #             if self.method['phi'] == 'Projection':
+        #                 ax[1].set_xlim(-1, 1)
+        #                 ax[1].set_ylim(-1, 1)
+        #                 # plot GMM
+        #                 window_dist = self.UpdateGMM(self.DistWindow, mix_dist_prob=None, device=self.device)
+        #                 if len(self.SfReprBuffer) > 0:
+        #                     psi_z = np.array(self.SfReprBuffer)
+        #                 else:
+        #                     psi_z = None
+        #                 PlotGMM(window_dist, psi_z=psi_z, fig=fig, ax=ax[1], device=self.device, dim=self.dim_option)
+        #             # plot Traj in Z-space
+        #             PCA_plot_traj(ax[1], All_Repr_obs_list, All_Goal_obs_list, path, path_len=self.max_path_length, is_goal=True)
+        #             filepath = os.path.join(path, "train_Maze_traj.png")
+        #             print(filepath)
+        #             plt.savefig(filepath) 
+        #             plt.close()
+        #             if self.save_debug == True or runner.step_itr % self.n_epochs_per_eval == 0:
+        #                 wandb.log(({"train_Maze_traj": wandb.Image(filepath)}))
+
+        #         else:
+        #             fig, ax = plt.subplots()
+        #             env = runner._env
+        #             list_viz_traj = []
+        #             All_Repr_obs_list = []
+        #             All_Goal_obs_list = []
+        #             for i in range(len(trajectories)):
+        #                 # plot phi
+        #                 if Pepr_viz:
+        #                     if self.method['phi'] == 'Projection':
+        #                         psi_s = self.Psi(self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean).cpu().numpy()
+        #                     else:
+        #                         psi_s = self.traj_encoder(torch.tensor(trajectories[i]['observations']).to(self.device)).mean.cpu().numpy()
+        #                     psi_g = trajectories[i]['agent_infos']['option']
+        #                     All_Repr_obs_list.append(psi_s)
+        #                     All_Goal_obs_list.append(psi_g)
         
-                    path = wandb.run.dir
-                    PCA_plot_traj(All_Repr_obs_list, All_Goal_obs_list, path, path_len=self.max_path_length, is_goal=True)
+        #             path = wandb.run.dir
+        #             PCA_plot_traj(All_Repr_obs_list, All_Goal_obs_list, path, path_len=self.max_path_length, is_goal=True)
   
         return trajectories
 
diff --git a/requirements.txt b/requirements.txt
index abdc87c..00bc348 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -41,7 +41,8 @@ executing==1.2.0
 fasteners==0.18
 fastjsonschema==2.17.1
 filelock==3.12.0
-flatbuffers==23.5.26
+# flatbuffers==23.5.26
+flatbuffers>=24.3.25
 fonttools==4.39.4
 fqdn==1.5.1
 future==0.18.3
@@ -50,18 +51,20 @@ gitdb==4.0.10
 GitPython==3.1.31
 glfw==2.5.9
 google-auth==2.19.1
-google-auth-oauthlib==0.4.6
+# google-auth-oauthlib==0.4.6
+google-auth-oauthlib
 google-pasta==0.2.0
 grpcio==1.54.2
 gym==0.17.2
 gym-notices==0.0.8
-h5py==3.8.0
+# h5py==3.8.0
+h5py>=3.10.0
 idna==3.4
 imageio==2.31.0
 imageio-ffmpeg==0.4.8
 importlib-metadata==6.6.0
 importlib-resources==5.12.0
-install==1.3.5
+#install==1.3.5
 ipykernel==6.23.1
 ipython==8.12.2
 ipython-genutils==0.2.0
@@ -85,7 +88,8 @@ jupyterlab==3.6.1
 jupyterlab-pygments==0.2.2
 jupyterlab-vim==0.16.0
 jupyterlab_server==2.22.1
-keras==2.10.0
+# keras==2.10.0
+keras==2.15.0
 Keras-Preprocessing==1.1.2
 kiwisolver==1.4.4
 labmaze==1.0.6
@@ -128,7 +132,9 @@ platformdirs==3.5.1
 proglog==0.1.10
 prometheus-client==0.17.0
 prompt-toolkit==3.0.38
-protobuf==3.19.4
+# protobuf==3.19.4
+# protobuf>=3.20.1
+protobuf>=3.20.3,<5
 psutil==5.9.5
 ptyprocess==0.7.0
 pure-eval==0.2.2
@@ -166,12 +172,17 @@ soupsieve==2.4.1
 stack-data==0.6.2
 sympy==1.12
 tabulate==0.9.0
-tensorboard==2.10.1
-tensorboard-data-server==0.6.1
+# tensorboard==2.10.1ad
+tensorboard>=2.11
+# tensorboard-data-server==0.6.1
+tensorboard-data-server
 tensorboard-plugin-wit==1.8.1
 tensorboardX==2.6
-tensorflow-estimator==2.10.0
-tensorflow==2.10.0
+# tensorflow-estimator==2.10.0
+tensorflow-estimator >= 2.15.0, < 2.16
+# tensorflow==2.10.0
+# tensorflow>=2.11
+tensorflow==2.15.0
 termcolor==2.3.0
 terminado==0.17.1
 threadpoolctl==3.1.0
@@ -192,7 +203,8 @@ webcolors==1.13
 webencodings==0.5.1
 websocket-client==1.5.2
 Werkzeug==2.3.4
-wrapt==1.15.0
+# wrapt==1.15.0
+wrapt >= 1.11.0, < 1.15
 y-py==0.5.9
 ypy-websocket==0.8.2
 zipp==3.15.0
diff --git a/run_large.sh b/run_large.sh
index f9c1d74..c108e28 100644
--- a/run_large.sh
+++ b/run_large.sh
@@ -1,4 +1,5 @@
 export CUDA_VISIBLE_DEVICES=0
 export MUJOCO_GL="osmesa"
 
-python tests/main.py --run_group Large --env ant_maze_large --max_path_length 300 --seed 0 --traj_batch_size 16 --n_parallel 4 --n_epochs_per_eval 500  --dim_option 4  --algo SZPC --exp_name TheBest --phi_type Projection --explore_type SZN  --trans_optimization_epochs 150  --is_wandb 1  --SZN_w2 10 --SZN_w3 3 --SZN_window_size 20 --SZN_repeat_time 3  --n_epochs 20000 --Repr_max_step 300 --dual_slack 1e-3 
+#python tests/main.py --run_group Large --env ant_maze_large --max_path_length 300 --seed 0 --traj_batch_size 16 --n_parallel 4 --n_epochs_per_eval 500  --dim_option 4  --algo SZPC --exp_name TheBest --phi_type Projection --explore_type SZN  --trans_optimization_epochs 150  --is_wandb 1  --SZN_w2 10 --SZN_w3 3 --SZN_window_size 20 --SZN_repeat_time 3  --n_epochs 20000 --Repr_max_step 300 --dual_slack 1e-3 
+python tests/main.py --run_group Large --env ant_maze_large --max_path_length 300 --seed 0 --traj_batch_size 16 --n_parallel 4 --n_epochs_per_eval 500  --dim_option 4  --algo metra --exp_name TheBest --phi_type Projection --explore_type SZN  --trans_optimization_epochs 150  --is_wandb 1  --SZN_w2 10 --SZN_w3 3 --SZN_window_size 20 --SZN_repeat_time 3  --n_epochs 20000 --Repr_max_step 300 --dual_slack 1e-3 
diff --git a/tests/main.py b/tests/main.py
index 0b26bc8..23e057b 100644
--- a/tests/main.py
+++ b/tests/main.py
@@ -1,4 +1,5 @@
 #!/usr/bin/env python3
+
 import tempfile
 import dowel_wrapper
 assert dowel_wrapper is not None
@@ -14,10 +15,13 @@ import torch.multiprocessing as mp
 if 'mac' in platform.platform():
     pass
 else:
+    print("HEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE")
     os.environ['MUJOCO_GL'] = 'egl'
     if 'SLURM_STEP_GPUS' in os.environ:
         os.environ['EGL_DEVICE_ID'] = os.environ['SLURM_STEP_GPUS']
 
+    os.environ["MUJOCO_PY_FORCE_CPU_RENDER"] = "true"
+
 # import better_exceptions
 import numpy as np
 
@@ -370,8 +374,8 @@ def run(ctxt=None):
         input_dim=args.traj_batch_size,
         output_dim=args.dim_option,
         init_std=3e-1,
-        min_std=args.SZP_std_min,   # 1e-1
-        max_std=args.SZP_std_max,   # 5e-1
+        min_std=1e-1, #args.SZP_std_min,   # 1e-1
+        max_std=5e-1, #args.SZP_std_max,   # 5e-1
         normal_distribution_cls=TanhNormal,
     )
     SampleZPolicy = module_cls(**module_kwargs)
@@ -450,7 +454,7 @@ def run(ctxt=None):
 
     replay_buffer = PathBufferTensor(capacity_in_transitions=int(args.sac_max_buffer_size), pixel_shape=pixel_shape)
 
-    if args.algo in ['metra', 'dads', 'metra', 'SZPC']:
+    if args.algo in ['metra', 'dads', 'RSD', 'SZPC']:
         qf1 = ContinuousMLPQFunctionEx(
             obs_dim=policy_q_input_dim,
             action_dim=action_dim,
@@ -581,6 +585,7 @@ def run(ctxt=None):
             **skill_common_args,
         )
     else:
+        print(f"{args.algo} is not implemented!")
         raise NotImplementedError
 
     if args.sample_cpu:
